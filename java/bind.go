package java

//extern void* a2(void *,void *);
//extern void* a3(void *,void *,void *);
//extern void* a4(void *,void *,void *,void *);
//extern void* a5(void *,void *,void *,void *,void *);
//extern void* a6(void *,void *,void *,void *,void *,void *);
//extern void* a7(void *,void *,void *,void *,void *,void *,void *);
//extern void* a8(void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* a9(void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* a10(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* a11(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* a12(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* b2(void *,void *);
//extern void* b3(void *,void *,void *);
//extern void* b4(void *,void *,void *,void *);
//extern void* b5(void *,void *,void *,void *,void *);
//extern void* b6(void *,void *,void *,void *,void *,void *);
//extern void* b7(void *,void *,void *,void *,void *,void *,void *);
//extern void* b8(void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* b9(void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* b10(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* b11(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* b12(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* c2(void *,void *);
//extern void* c3(void *,void *,void *);
//extern void* c4(void *,void *,void *,void *);
//extern void* c5(void *,void *,void *,void *,void *);
//extern void* c6(void *,void *,void *,void *,void *,void *);
//extern void* c7(void *,void *,void *,void *,void *,void *,void *);
//extern void* c8(void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* c9(void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* c10(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* c11(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* c12(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* d2(void *,void *);
//extern void* d3(void *,void *,void *);
//extern void* d4(void *,void *,void *,void *);
//extern void* d5(void *,void *,void *,void *,void *);
//extern void* d6(void *,void *,void *,void *,void *,void *);
//extern void* d7(void *,void *,void *,void *,void *,void *,void *);
//extern void* d8(void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* d9(void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* d10(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* d11(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* d12(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* e2(void *,void *);
//extern void* e3(void *,void *,void *);
//extern void* e4(void *,void *,void *,void *);
//extern void* e5(void *,void *,void *,void *,void *);
//extern void* e6(void *,void *,void *,void *,void *,void *);
//extern void* e7(void *,void *,void *,void *,void *,void *,void *);
//extern void* e8(void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* e9(void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* e10(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* e11(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* e12(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* f2(void *,void *);
//extern void* f3(void *,void *,void *);
//extern void* f4(void *,void *,void *,void *);
//extern void* f5(void *,void *,void *,void *,void *);
//extern void* f6(void *,void *,void *,void *,void *,void *);
//extern void* f7(void *,void *,void *,void *,void *,void *,void *);
//extern void* f8(void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* f9(void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* f10(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* f11(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* f12(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* g2(void *,void *);
//extern void* g3(void *,void *,void *);
//extern void* g4(void *,void *,void *,void *);
//extern void* g5(void *,void *,void *,void *,void *);
//extern void* g6(void *,void *,void *,void *,void *,void *);
//extern void* g7(void *,void *,void *,void *,void *,void *,void *);
//extern void* g8(void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* g9(void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* g10(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* g11(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
//extern void* g12(void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *,void *);
import "C"
import (
	"fmt"
	"github.com/wstjf/gojni/native"
	"reflect"
	"strings"
	"unsafe"

	"github.com/wstjf/gojni/jni"
	"github.com/wstjf/gojni/utils"
)

type nativeWarp struct {
	sCls         string
	jCls         jni.Jclass
	env          *jni.Env
	natives      []jni.JNINativeMethod
	isRegistered bool
}

type method struct {
	fn  interface{}
	sig []args
}

type args struct {
	jSig string
	gSig reflect.Type
}

var nMap = map[int][]unsafe.Pointer{
	2:  {C.a2, C.b2, C.c2, C.d2, C.e2, C.f2, C.g2},
	3:  {C.a3, C.b3, C.c3, C.d3, C.e3, C.f3, C.g3},
	4:  {C.a4, C.b4, C.c4, C.d4, C.e4, C.f4, C.g4},
	5:  {C.a5, C.b5, C.c5, C.d5, C.e5, C.f5, C.g5},
	6:  {C.a6, C.b6, C.c6, C.d6, C.e6, C.f6, C.g6},
	7:  {C.a7, C.b7, C.c7, C.d7, C.e7, C.f7, C.g7},
	8:  {C.a8, C.b8, C.c8, C.d8, C.e8, C.f8, C.g8},
	9:  {C.a9, C.b9, C.c9, C.d9, C.e9, C.f9, C.g9},
	10: {C.a10, C.b10, C.c10, C.d10, C.e10, C.f10, C.g10},
	11: {C.a11, C.b11, C.c11, C.d11, C.e11, C.f11, C.g11},
	12: {C.a12, C.b12, C.c12, C.d12, C.e12, C.f12, C.g12},
}

var (
	statistics = make(map[int]int)
	fMappers   = make(map[string]method)
)

const (
	max_index = 10
	max_dep   = 6
)

type Register interface {
	GetVm() jni.VM
	WithClass(cls string) *nativeWarp
	Done()
}

type registerImpl struct {
	vm       jni.VM
	instance *nativeWarp
}

func (reg *registerImpl) GetVm() jni.VM {
	return reg.vm
}

func (reg *registerImpl) Done() {
	if reg.instance != nil {
		reg.instance.Done()
	}
}

func (reg *registerImpl) WithClass(cls string) *nativeWarp {
	if reg.vm == 0 {
		panic("forbid")
	}
	reg.Done()
	reg.instance = withClass(cls)
	return reg.instance
}

func withClass(cls string) *nativeWarp {
	env := jni.AutoGetCurrentThreadEnv()
	jCls := env.FindClass(strings.ReplaceAll(cls, ".", "/"))
	if jCls == 0 {
		jni.ThrowException(fmt.Sprintf("not find class %s", cls))
	}
	return &nativeWarp{jCls: jCls, sCls: cls, env: env}
}

func (n *nativeWarp) WithClass(cls string) *nativeWarp {
	n.Done()
	return withClass(cls)
}

func (n *nativeWarp) getPFunc(inNum int) (int, int, string) {

	if inNum >= max_index {
		panic(fmt.Sprintf("function param overflow max %d numIN %d", max_index, inNum))
	}
	dep := statistics[inNum]
	if dep >= max_dep {
		inNum++
		return n.getPFunc(inNum)
	}
	code := fmt.Sprintf("%c%d", dep+97, inNum)
	return inNum, dep, code
}

func (n *nativeWarp) BindNative(javaMethodName string, def string, fun interface{}) *nativeWarp {
	jni.CheckNull(n.jCls, fmt.Sprintf("not find class %s", n.sCls))
	ms := native.EncodeToSig(def)
	//fmt.Println(ms.Sig)
	inNum := len(ms.ParamTyp) + 2
	goF := reflect.TypeOf(fun)
	if len(ms.ParamTyp) != goF.NumIn() {
		panic(fmt.Sprintf("method %s not match fun %s %d", javaMethodName, ms.ParamTyp, goF.NumIn()))
	}
	newNum, dep, code := n.getPFunc(inNum)
	var mArgs []args
	for i := 0; i < goF.NumIn(); i++ {
		n.CheckType(i, javaMethodName, def, ms.ParamTyp[i].GetSigType(), goF.In(i))
		mArgs = append(mArgs, args{
			jSig: ms.ParamTyp[i].GetSigType(),
			gSig: goF.In(i),
		})
	}
	if goF.NumOut() > 0 {
		n.CheckReturn(javaMethodName, ms.RetTyp.GetSigType(), goF.Out(0))
	}

	fMappers[code] = method{
		fn:  fun,
		sig: mArgs,
	}
	cf := nMap[newNum][dep]
	n.natives = append(n.natives, jni.JNINativeMethod{Name: javaMethodName, Sig: ms.Sig, FnPtr: cf})
	statistics[newNum] += 1
	return n
}

var checkMap = map[string]reflect.Type{
	"[I":                  reflect.TypeOf((*[]int32)(nil)).Elem(),
	"[Ljava/lang/String;": reflect.TypeOf((*[]string)(nil)).Elem(),
	"[B":                  reflect.TypeOf((*[]byte)(nil)).Elem(),
	"[J":                  reflect.TypeOf((*[]int)(nil)).Elem(),
	"[F":                  reflect.TypeOf((*[]float32)(nil)).Elem(),
	"[D":                  reflect.TypeOf((*[]float64)(nil)).Elem(),

	"I":                  reflect.TypeOf((*int32)(nil)).Elem(),
	"Ljava/lang/String;": reflect.TypeOf((*string)(nil)).Elem(),
	"B":                  reflect.TypeOf((*byte)(nil)).Elem(),
	"J":                  reflect.TypeOf((*int)(nil)).Elem(),
	"Z":                  reflect.TypeOf((*bool)(nil)).Elem(),
	//"F":                   reflect.TypeOf((*float32)(nil)).Elem(),
	//"D":                   reflect.TypeOf((*float64)(nil)).Elem(),
}

func (n *nativeWarp) CheckReturn(mName string, jsig string, gTyp reflect.Type) {
	if v, b := checkMap[jsig]; !b || v != gTyp {
		if b {
			panic(fmt.Sprintf("\n%s method %s return { %s  } not match go type {%s} \nmust use go type ==> %s",
				n.sCls, mName, jsig, gTyp, v))
		} else {
			panic(fmt.Sprintf("%s method %s return { %s  }  not support", n.sCls, mName, jsig))
		}
	}
}

func (n *nativeWarp) CheckType(i int, mName string, def string, jsig string, gTyp reflect.Type) {
	if v, b := checkMap[jsig]; !b || v != gTyp {
		if b {
			panic(fmt.Sprintf("\n%s method %s definition { %s %d } not match go type {%s} \nmust use go type ==> %s",
				n.sCls, mName, def, i, gTyp, v))
		} else {
			panic(fmt.Sprintf("%s method %s definition { %s %d } sig %s not support", n.sCls, mName, def, i, jsig))
		}
	}
}

func (n *nativeWarp) Done() {
	if n.env.RegisterNatives(n.jCls, n.natives) < 0 && !n.isRegistered {
		fmt.Println("java class: ", n.sCls)
		n.printNative()
		panic("RegisterNatives error \nplease check java nativeWarp define ")
	} else {
		n.isRegistered = true
	}
}

func (n *nativeWarp) printNative() {
	for _, nativeMethod := range n.natives {
		fmt.Printf("%s %s\n", utils.Wp(nativeMethod.Name, 30), utils.Wp(nativeMethod.Sig, 100))
	}
}
